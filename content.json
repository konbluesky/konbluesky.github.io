{"posts":[{"title":"Carry-Coin 架构设计 Core模块(1)","text":"Carry-Coin Core的Center，Decenter,protocol的设计 Core组成部分Swap基本概念 SwapEngine 套利引擎，内部独立线程，Handler执行 ，Center构建,Job注册 SwapEngine最初设计可以支持dex(n)&lt;-&gt;cex(n),目前阶段仅SingleSwapEngine 实现了dex(1，n)&lt;-&gt;cex(1)的套利动作,即一个Engine绑定1个cex和N个dex； SwapContext(标记接口) SwapContext是SwapEngine的上下文，是个巨型类，为了跨交易所共用上下文预留的,主要是保存SwapEngine运行时的数据，包含了所有重要对象的引用：交易所信息，交易对信息，交易所账户信息; SwapConfig SwapConfig是SwapEngine的配置类，主要是保存SwapEngine运行时所需的配置信息; SwapHandler 用来初始化Context，同步job的阻塞加载，异步job的注册，BizDataLoaderContext首次初始化和校验 SwapInitializerConfig 根据yml初始化SwapLauncher来触发Engine工作； SwapLauncher 交易引擎启动器 Center Cex中心交易所相关的抽象和套利动作 CenterExchangeHolder 中心交易所的顶级抽象，主要是一些技术动作： 注册同步和异步的取数器（Job），获取Context数据等动作 交易所支持同步和异步取数两种模式，同步在SwapEngine初始化时执行一次，异步周期性运行； 周期性执行使用ScheduledExecutorService，实现使用了alibaba的transmittable-thread-local库，主要目的解决异步执行时上下文传递的问题； Job方式取来的数据都会放在BizDataLoaderContext容器中； AbstractCenterExchangeHolder 对CenterExchangeHolder的基本实现 CenterExchangeHolderBehavior 业务动作抽象接口：Limit/Marker下单，撤单，获取订单状态，提现，转账等业务动作,这个接口也是pipeline和job中操作Cex的核心，非必要业务流中不操作CenterExchangeHolder,AbstractCenterExchangeHolder这种顶级接口； Cex交易所操作使用Xchange完成; FacilitySupport 提供一套基本的Cex实现模板 CenterSymbolInfo Cex侧套利相关配置信息 Decenter Dex去中心交易平台相关的抽象, Decenter.protocol Decenter中SwapProtocol协议抽象，目前已实现包含solana,bsc链，odos,zerox平台的询价、交易动作;设计过程中难点在于对不同链的交易动作进行同一视角进行抽象和设计； EVM部分 GenericWeb3jBehavior 链上动作的通用抽象，默认只实现getNetwork,getWeb3jManager,考虑到多链支持Client客户端不定，所以作为泛型传入； 必要动作queryTxConfirmed,getRawAmountOut,getBalanceOfNode做抽象方法，考虑到这几个方法不挑网络，入参回参明确，所以放在此处； 不同链差异化动作放在下层实现. EthGenericWeb3jBehavior 具象evm链的实现，主要是实现网络层面、Token层面的一些方法了allowance, getTransactionGasLimit, signTransaction, waitTxConfirmed, queryTxConfirmed, getNonce, getBalanceOfNode, tokenTransfer, getGasProvider, gasProvider GenericSwapV2Impl,GenericSwapV3Impl 基于EthGenericWeb3jBehavior完成Dex swap全过程的方法,包含：getAmountsOut,swapExactTokensForTokens，swapExactTokensForTokensSupportingFeeOnTransferTokens getRawAmountOut区别于getAmountsOut，是用来通过evm中log数据获取最终交换到的token数量； SwapExactTForTParam 上层通过该类传入swap所需参数； Solana部分ODOS部分Strategy 交易策略 swap 套利动作","link":"/2024/10/14/carry_coin_architecture_2/"},{"title":"Carry-Coin 一个自动化搬砖套利平台","text":"Carry-Coin 是一个套利程序，程序从23年初开始开发至今，目前已经基本稳定，现在将程序的设计整理出来；套利思路很简单：程序监控Cex和Dex平台，针对同一币种发现差价后自动化搬运； carry-config-generator(python) 框架:web3,pandas ; 工程主要负责根据dex,cex，第三方：1inch,odos,dexscreener 数据，进行数据分析最终生成套利配置； carry-core (Java) 一个基于Java的套利核心程序，dex&lt;-&gt;cex套利逻辑的顶层抽象,SwapEngine，SwapStategy, ArbitrageProcessor,CenterExchange,DecenterExchanage,SwapProtocol 等; carry-worker (Java) 框架:Springboot3.2.5,Xchange,Web3j,RxJava3,Guava等；工程基于core实现的不同dex,cex的监控、告警、通知、搬运、买卖逻辑； carry-protocol-adapter(Nodejs) 基于Uniswap-sdk ,jupiter-swap-api(solana)开发的套利协议适配器，适配v2/v3询价； carry-web-front (Nodejs) Vue3.0+TypeScript+Vite5+Ant-Design-Vue等，工程主要管理平台的前端页面，包括套利开关、线上配置、交易数据监控，链上数据监控报表等； carry-web-server (Java) 框架: Spring Cloud Alibaba, Mysql, 管理平台的后端服务； 部署架构 程序截图 技术栈语言 Java 11 Python Nodejs Bash Shell 框架Java Spring Boot JPA Xchange RxJava Guava transmittable-thread-local fastjson web3j lombok assertj jasypt Hutool Slf4j、Logback Python Flask pickledb web3 pandas Nodejs pm2 uniswap-core,V2/v3-sdk solana/web3、spl-token nestjs ethers.js 平台 jeecg-boot","link":"/2024/10/13/carry_coin_architecture_1/"},{"title":"Carry-Coin 架构设计 SymbolLedger (4)","text":"Carry-Coin 套利币本 SymbolLedger 设计，SymbolLedger负责存放套利过程中交易对信息，其中包括symbol在Cex中的各项配置、套利阈值等，Dex中的各种合约信息、阈值、交易参数等 SymbolLedger一个交易所对应一个SymbolLedger实例,程序启动后通过json配置文件进行加载； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * &lt;pre&gt; * 此类用来存储市面上所有的交易对信息 * 维护方式: 基础信息手工,其他信息通过程序自动获取; * 更新周期: 定期更新; * 作用: 以此账簿上的币作为循化基础,再从各交易所拉取对应信息; * &lt;/pre&gt; * &lt;p&gt; @Date : 2023/3/21 &lt;/p&gt; * &lt;p&gt; @Project : block-farming&lt;/p&gt; * * &lt;p&gt; @author konbluesky &lt;/p&gt; */@Slf4j@Datapublic class SymbolLedger { /** * 如是内存模式则不进行数据库持久化 */ private boolean memoryMode = false; /** * 更新symbolPairConfigs时,一定要重新对symbolPairConfigMap和symbolPairConfigMap_symbolKey进行更新 * 否则getSymbolPairConfig会失效 * @param symbolPairConfigs */ public void setSymbolPairConfigs(List&lt;SymbolPairConfig&gt; symbolPairConfigs) { this.symbolPairConfigs = symbolPairConfigs; for(SymbolPairConfig symbolPairConfig : symbolPairConfigs){ updateSymbolPairConfig(symbolPairConfig); } log.info(&quot;SymbolLedger更新symbolPairConfigs&quot;); } private List&lt;SymbolPairConfig&gt; symbolPairConfigs = Lists.newCopyOnWriteArrayList(); private Map&lt;String, SymbolPairConfig&gt; symbolPairConfigMap = Maps.newConcurrentMap(); private Map&lt;String, SymbolPairConfig&gt; symbolPairConfigMap_symbolKey = Maps.newConcurrentMap(); // private Table&lt;String, String, SymbolPairConfig&gt; symbolPairConfigMap = Tables.synchronizedTable(HashBasedTable.create()); public void put(SymbolPairConfig symbolPairConfig) { symbolPairConfigs.add(symbolPairConfig); updateSymbolPairConfig(symbolPairConfig); } private void updateSymbolPairConfig(SymbolPairConfig symbolPairConfig){ CenterSymbolInfo centerSymbolInfo = symbolPairConfig.getCenterSymbolInfo(); symbolPairConfigMap.put(centerSymbolInfo.getBaseCurrency() .toLowerCase(), symbolPairConfig); symbolPairConfigMap_symbolKey.put(centerSymbolInfo.getBaseCurrency() .toLowerCase() + &quot;/&quot; + centerSymbolInfo.getQuoteCurrency() .toLowerCase(), symbolPairConfig); } @Deprecated public SymbolPairConfig getSymbolPairConfig(String baseCurrency) { return symbolPairConfigMap.get(baseCurrency.toLowerCase()); } public List&lt;SymbolPairConfig&gt; getSymbolPairConfigsBy(String baseCurrency) { List&lt;SymbolPairConfig&gt; result = Lists.newArrayList(); symbolPairConfigMap_symbolKey.forEach((k, v) -&gt; { if(k.toLowerCase().startsWith(baseCurrency.toLowerCase())) { result.add(v); } }); return result; } public SymbolPairConfig getSymbolPairConfig(String baseCurrency, String quoteCurrency) { return symbolPairConfigMap_symbolKey.get(baseCurrency.toLowerCase() + &quot;/&quot; + quoteCurrency.toLowerCase()); }} SymbolLedger构建的静态工厂,json配置通过carry-config-generator(python)生成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249/** * &lt;pre&gt; * 1. 交易对配置文件工厂,目前实现从HUOBI.txt文件中读取; * 2. 可以在jar包所在目录下创建config目录,将配置文件放入config目录下,程序会自动读取; * &lt;/pre&gt; */@Slf4jpublic class SymbolLedgerFactory { public static final String SYMBOL_HUOBI_BOOKS_FILE = &quot;HUOBI.txt&quot;; public static final String SYMBOL_XT_BOOKS_FILE = &quot;XT.txt&quot;; public static final String SYMBOL_BINANCE_BOOKS_FILE = &quot;BIAN.txt&quot;; public static final String SYMBOL_MEXC_BOOKS_FILE = &quot;MXCAll.txt&quot;; public static final String SYMBOL_GATEIO_BOOKS_FILE = &quot;GATEIO.txt&quot;; public static final String SYMBOL_KUCOIN_BOOKS_FILE = &quot;KUCOIN.txt&quot;; /** * TODO 从文件中读取交易对配置,目前只解析部分字段;有需要实时更新的字段到时候从服务器上实时拉取; * swapStableCoinContractAdd 字段配置决定了与交易所的对的匹配; * * @param symbolBooksFile * @param swapConfig * @return */ private static SymbolLedger create(String symbolBooksFile, SwapConfig swapConfig) { Preconditions.checkArgument(swapConfig != null); JSONArray jsonArray = getJsonArrayByFile(symbolBooksFile); SymbolLedger symbolLedger = new SymbolLedger(); for (int i = 0; i &lt; jsonArray.size(); i++) { JSONObject item = jsonArray.getJSONObject(i); // continue to parse the json object if (Strings.isNullOrEmpty(item.getString(&quot;swapContract&quot;)) || item.getString(&quot;swapStableCoinContract&quot;) .equalsIgnoreCase(&quot;cake&quot;)) { continue; } SymbolPairConfig symbolPairConfig = new SymbolPairConfig(); symbolPairConfig.setBaseCurrency(item.getString(&quot;swapCoinContract&quot;)); int chainId = item.getInteger(&quot;chainId&quot;) != null ? item.getInteger(&quot;chainId&quot;) : NetworkEnum.BSC.getChainId(); String stableName = SymbolTokenHelper.getTokenInfoByAddressReturnSymbol(chainId, item.getString(&quot;swapStableCoinContractAdd&quot;)); symbolPairConfig.setQuoteCurrency(Currency.USDT.getCurrencyCode()); // symbolPairConfig.setSymbol(symbolPairConfig.getBaseCurrency() + &quot;/&quot; + symbolPairConfig.getQuoteCurrency()); // 链上交易对和cex交易对 分别存储,交易所对,目前统一使用usdt CenterSymbolInfo centerSymbolInfo = new CenterSymbolInfo(); centerSymbolInfo.setBaseCurrency(symbolPairConfig.getBaseCurrency()); centerSymbolInfo.setQuoteCurrency(Currency.USDT.getCurrencyCode()); centerSymbolInfo.setCexMaxOrderForUSDT(item.getBigDecimal(&quot;maxOrderForUsdt&quot;) == null ? swapConfig.getGlobalMaxOrderForUsdt() : item.getBigDecimal(&quot;maxOrderForUsdt&quot;)); centerSymbolInfo.setCexMinOrderForUSDT(item.getBigDecimal(&quot;minOrderForUsdt&quot;) == null ? swapConfig.getGlobalMinOrderForUsdt() : item.getBigDecimal(&quot;minOrderForUsdt&quot;)); centerSymbolInfo.getAskPosition() .set(item.getInteger(&quot;askPosition&quot;) == null || item.getInteger(&quot;askPosition&quot;) == 0 ? 3 : item.getInteger(&quot;askPosition&quot;)); symbolPairConfig.setCenterSymbolInfo(centerSymbolInfo); // 设置去中心化交易所配置信息; DecenterSymbolInfo decenterSymbolInfo = new DecenterSymbolInfo(); decenterSymbolInfo.setBaseCurrency(symbolPairConfig.getBaseCurrency()) .setQuoteCurrency(stableName == null ? CoinEnum.getCoin(item.getString(&quot;swapStableCoinContractAdd&quot;)) .name() : stableName) .setMiddleCurrency(item.getString(&quot;swapMiddleCoinContract&quot;)) .setDexName(item.getString(&quot;dex_name&quot;)) .setDexProtocolVersion(item.getString(&quot;liquidity_type&quot;)) // 链id .setChainIds(Set.of(chainId)) .setStableCoinContractAddress(item.getString(&quot;swapStableCoinContractAdd&quot;)) .setMiddleCoinContractAddress(item.getString(&quot;swapMiddleCoinContractAdd&quot;)) .setTradeCoinContractAddress(item.getString(&quot;swapCoinContractAdd&quot;)) .setSwapContractAddress(item.getString(&quot;swapContract&quot;)) .setBurnFee(item.getBigDecimal(&quot;burn&quot;)) .setBuyTax(item.getBigDecimal(&quot;buyTax&quot;))// 买入税率 .setSellTax(item.getBigDecimal(&quot;sellTax&quot;))//卖出税率 // .setSellTax(item.getBigDecimal(&quot;burn&quot;))// 卖出税率， 老的配置文件中就是sellTax .setDexBuySlipPoint(item.getBigDecimal(&quot;dexSlipPoint&quot;) .add(swapConfig.getGlobalDexSlipPoint())) .setStableCoinDecimals(item.getIntValue(&quot;stableCoinDecimals&quot;)) .setTradeCoinDecimals(item.getIntValue(&quot;coinDecimals&quot;)) .setMiddleCoinDecimals(item.getIntValue(&quot;middleCoinDecimals&quot;)) .setMethod(item.getString(&quot;method&quot;)) .setBuyPosition(item.getIntValue(&quot;currentDepthPosition&quot;)) .setReplyPro(item.getBigDecimal(&quot;replyPro&quot;)) // 反向利润放大的比例 .setDepthPro(item.getBigDecimal(&quot;depthPro&quot;)) // 反向深度缩小的比例 .setV3LoopContractAddress(item.getString(&quot;lpAdd&quot;)) // v3 的loopAddress .setV3Fee(item.getString(&quot;feev3&quot;)) // v3 的fee .setDexMaxOrderForUSDT(item.getBigDecimal(&quot;dexMax&quot;) == null ? swapConfig.getGlobalMaxOrderForUsdt() : item.getBigDecimal(&quot;dexMax&quot;)) // 反向最大下单量 .setDexMinOrderForUSDT(item.getBigDecimal(&quot;dexMin&quot;) == null ? swapConfig.getGlobalMinOrderForUsdt() : item.getBigDecimal(&quot;dexMin&quot;));// 反向最小下单量 decenterSymbolInfo.setExtensionDexHandlerConfig(new ExtensionDexHandlerConfig(item)); decenterSymbolInfo.init(); symbolPairConfig.setDecenterSymbolInfo(decenterSymbolInfo); symbolPairConfig.set_rawJson(item); symbolLedger.put(symbolPairConfig); } return symbolLedger; } private static JSONArray getJsonArrayByFile(String symbolHuobiBooksFile) { File configFile = PathUtil.stairsLoad(symbolHuobiBooksFile, &quot;config&quot;); try { if (configFile == null) { log.warn(&quot;Not fount SymbolBook config file.{}&quot;, symbolHuobiBooksFile); String tempPath = System.getProperty(&quot;java.io.tmpdir&quot;) + System.currentTimeMillis(); String tempFile = Paths.get(tempPath, File.separator, symbolHuobiBooksFile) .toString(); Resource resource = new ClassPathResource(symbolHuobiBooksFile); InputStream initialStream = resource.getInputStream(); byte[] buffer = new byte[initialStream.available()]; initialStream.read(buffer); configFile = new File(tempFile); configFile.getParentFile() .mkdirs(); Files.write(buffer, configFile); log.info(&quot;Loading default SymbolBook config file from classpath: {} &quot;, resource.getURL()); } String jsonContext = Joiner.on(&quot;&quot;) .join(Files.readLines(configFile, Charsets.UTF_8)); if (JSON.isValidArray(jsonContext)) { return JSON.parseObject(jsonContext, JSONArray.class); } } catch (Exception e) { log.error(e.getMessage(), e); throw new SwapException(&quot;SymbolBook config loading failed.&quot;); } return new JSONArray(); } public static SymbolLedger createXT(SwapConfig swapConfig) { return create(SYMBOL_XT_BOOKS_FILE, swapConfig); } public static SymbolLedger createHuoBi() { return create(SYMBOL_HUOBI_BOOKS_FILE, new SwapConfig()); } public static SymbolLedger createGateio() { return create(SYMBOL_GATEIO_BOOKS_FILE, new SwapConfig()); } public static SymbolLedger createGateio(SwapConfig swapConfig) { return create(SYMBOL_GATEIO_BOOKS_FILE, swapConfig); } public static SymbolLedger createKucoin(SwapConfig swapConfig) { return create(SYMBOL_KUCOIN_BOOKS_FILE, swapConfig); } public static SymbolLedger createOKex() { return create(SYMBOL_HUOBI_BOOKS_FILE, new SwapConfig()); } public static SymbolLedger createOKex(SwapConfig swapConfig) { return create(SYMBOL_HUOBI_BOOKS_FILE, swapConfig); } public static SymbolLedger createHuoBi(SwapConfig swapConfig) { return create(SYMBOL_HUOBI_BOOKS_FILE, swapConfig); } public static SymbolLedger createBinance(SwapConfig swapConfig) { return create(SYMBOL_BINANCE_BOOKS_FILE, swapConfig); } public static SymbolLedger createMEXC(SwapConfig swapConfig) { return create(SYMBOL_MEXC_BOOKS_FILE, swapConfig); } /** * 将配置文件内容刷入db * 外部通过SwapControlHolder 来对状态进行控制和判断 * * @param symbolLedger * @param exchangeType * @param isMonitor 开关用来控制swapSymbolPairConfigRecord 记录默认是监听状态还是， 非监听状态， * 首次程序启动的时候是非监听的，需要web端显式的开启，后续job中动态调整默认都是监听状态的 */ public static void flushToDb(SymbolLedger symbolLedger, ExchangeType exchangeType, boolean isMonitor) { if (symbolLedger.isMemoryMode()) { return; } SwapSymbolPairConfigRecordRepository res = SpringUtil.getBean(SwapSymbolPairConfigRecordRepository.class); res.deleteAllByExchangeType(exchangeType); res.flush(); List&lt;SwapSymbolPairConfigRecord&gt; all = Lists.newArrayList(); symbolLedger.getSymbolPairConfigs().forEach(symbolPairConfig -&gt; { SwapSymbolPairConfigRecord swapSymbolPairConfigRecord = null; if (isMonitor) { swapSymbolPairConfigRecord = SwapSymbolPairConfigRecord.createLoadMonitor(symbolPairConfig, exchangeType); SwapControlManager.putItem(exchangeType, symbolPairConfig.getUniDexIdentify(), swapSymbolPairConfigRecord); } else { swapSymbolPairConfigRecord = SwapSymbolPairConfigRecord.createUnMonitor(symbolPairConfig, exchangeType); SwapControlManager.putItem(exchangeType, symbolPairConfig.getUniDexIdentify(), swapSymbolPairConfigRecord); } all.add(swapSymbolPairConfigRecord); }); res.saveAllAndFlush(all); log.info(&quot;Load config from config file, Flush to db is ok ! Record size is :{} &quot;, all.size()); } /** * 增量更新配置文件 * 1. 数据库中载入当前交易所币配置 * 2. 从内存中获取当前交易所币配置 * 3. 比较数据库中不在内存的配置，更新状态 * 4. 将关闭的币种组装日志打印出来 */ public static void incrementalUpdate(SymbolLedger symbolLedger, ExchangeType exchangeType) { if (symbolLedger.isMemoryMode()) { return; } SwapSymbolPairConfigRecordRepository res = SpringUtil.getBean(SwapSymbolPairConfigRecordRepository.class); List&lt;SwapSymbolPairConfigRecord&gt; all = res.findAllByExchangeType(exchangeType); String changeCurrency = &quot;&quot;; int closeCount = 0; for (SwapSymbolPairConfigRecord swapSymbolPairConfigRecord : all) { String symbol = swapSymbolPairConfigRecord.getSymbol(); if (symbolLedger.getSymbolPairConfig(symbol.split(&quot;/&quot;)[0], symbol.split(&quot;/&quot;)[1]) == null) { swapSymbolPairConfigRecord.setMonitorStatus(SwapSymbolPairConfigRecord.MonitorStatus.UNMONITOR); changeCurrency += symbol + &quot;,&quot;; closeCount++; } } res.saveAllAndFlush(all); String msg = Utils.format(&quot;{} 交易所内存币本配置已过滤,总数:{} 关闭数量:{} 关闭币种:{}&quot;, exchangeType, all.size(), closeCount, changeCurrency); log.info(msg); SwapMessageSender.sendMessage(exchangeType, msg); log.info(&quot;Incremental update config from config file, Flush to db is ok ! Record size is :{} &quot;, all.size()); } SymbolPairConfig 类, 用来存储某个交易对(ABC/USDT)的配置信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * &lt;p&gt; @Date : 2023/3/21 &lt;/p&gt; * &lt;p&gt; @Project : block-farming&lt;/p&gt; * * &lt;p&gt; @author konbluesky &lt;/p&gt; */@Datapublic class SymbolPairConfig { //TODO 现阶段 symbolInfo 是1-1关系 /** * 交易对在中心化交易所的信息 */ private CenterSymbolInfo centerSymbolInfo; /** * 交易对在去中心化交易所的信息 */ private DecenterSymbolInfo decenterSymbolInfo; /** * 交易对显示名称 BTC/USDT */ public String getSymbol() { return baseCurrency+&quot;/&quot;+quoteCurrency; } /** * RITE/USDT-RITE/USDT-PancakeV2-UniV2 * @return */ public String getUniDexIdentify(){ return centerSymbolInfo.getSymbol() + &quot;-&quot; + decenterSymbolInfo.getSymbol() + &quot;-&quot; + decenterSymbolInfo.getDexName() + &quot;-&quot; + decenterSymbolInfo.getDexProtocolVersion(); } /** * 交易对基础货币 BTC */ private String baseCurrency; /** * 交易对报价货币 USDT */ private String quoteCurrency; /** * 允许开启的实例数 */ private AtomicInteger reverseAllowInstanceNum = new AtomicInteger(1); private AtomicInteger forwardAllowInstanceNum = new AtomicInteger(1); /** * 开启翻倍后，设置x分钟激情时间，进行翻倍 */ private AtomicLong reversePassionTime = new AtomicLong(0); private AtomicLong forwardPassionTime = new AtomicLong(0); /** * 交易对的利润阈值,一般在交易所holder初始化的时候从SwapConfig获取; * TODO 这里的阈值可基于全局的做覆盖; */ private BigDecimal profitThreshold; private BigDecimal profitThresholdRate; private BigDecimal _origin_profitThresholdRate; private JSONObject _rawJson; public void setProfitThresholdRate(BigDecimal profitThresholdRate) { this.profitThresholdRate = profitThresholdRate; this._origin_profitThresholdRate = profitThresholdRate; } public void setProfitThresholdRateDouble() { profitThresholdRate = profitThresholdRate.multiply(new BigDecimal(&quot;1.3&quot;)); } public void resetProfitThresholdRate() { profitThresholdRate = _origin_profitThresholdRate; } /** * 提现次数自增一次 * Increase WithdrawTime */ public void increaseWithdrawTimes() { centerSymbolInfo.getLastWithdrawTime().set(System.currentTimeMillis()); centerSymbolInfo.increaseWithdrawTimes(); } public boolean isMiddleCoin() { return !Strings.isNullOrEmpty(decenterSymbolInfo.getMiddleCoinContractAddress()); } public String getSymbolNoOblique() { return getSymbol().replace(&quot;/&quot;, &quot;&quot;); }} CenterSymbolInfo 类, 用来存储某个交易对(ABC/USDT)的Cex配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** * * &lt;p&gt; @Date : 2023/3/20 &lt;/p&gt; * &lt;p&gt; @Project : block-farming&lt;/p&gt; * * &lt;p&gt; @author konbluesky &lt;/p&gt; */@Data@Slf4jpublic class CenterSymbolInfo { public String getSymbol() { return baseCurrency + &quot;/&quot; + quoteCurrency; } /** * 注意这里是[交易所]对应的基础货币 BTC */ private String baseCurrency; /** * 注意这里是[交易所]对应的交易对报价货币 USDT */ private String quoteCurrency; private Double price; /** * 交易所体现时一般需要指定链名或者网络名 */ private String chainName; /** * 提现次数 */ private AtomicInteger withdrawTimes = new AtomicInteger(0); /** * 最小提现手续费 */ private BigDecimal withdrawMinFee = BigDecimal.ZERO; /** * 手续费换算成美元 */ private BigDecimal withdrawMinFee$ = BigDecimal.ZERO; /** * 传入实时的单价，计算出手续费绝对刀 * @param unitPrice */ public void setWithdrawMinFee$(BigDecimal unitPrice) { this.withdrawMinFee$ = Utils.getScale(unitPrice.multiply(withdrawMinFee)); } /** * 最后一次的提现时间 */ private AtomicLong lastWithdrawTime = new AtomicLong(System.currentTimeMillis()); /** * 最后一次下卖单时间 */ private AtomicLong lastPlaceSellOrderTime = new AtomicLong(System.currentTimeMillis()); private AtomicLong lastPlaceBuyOrderTime = new AtomicLong(System.currentTimeMillis()); /** * 卖单默认位置,此位置是口语中的卖一卖二，不是数组下标 */ private AtomicInteger askPosition = new AtomicInteger(0); /** * 挂单检查时间(卖单) */ private int askOrderWaitSeconds = 5; /** * 交易所固定最大下单金额(usdt为单位) */ private BigDecimal CexMaxOrderForUSDT; /** * 交易所固定最小下单金额(usdt为单位) */ private BigDecimal CexMinOrderForUSDT; /** * 留币时保存的卖出下单ID; * remain 留存 sell 出售 orderId 订单ID */ private String remainSellOrderId; /** * 提现次数自增一次 */ public void increaseWithdrawTimes() { withdrawTimes.set(withdrawTimes.get() + 1); }} DecenterSymbolInfo 类, 用来存储某个交易对(ABC/USDT)的Dex配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245/** * &lt;p&gt; @Date : 2023/3/20 &lt;/p&gt; * &lt;p&gt; @Project : block-farming&lt;/p&gt; * * &lt;p&gt; @author konbluesky &lt;/p&gt; */@Accessors(chain = true)@Data@Slf4jpublic class DecenterSymbolInfo { private String dexName; private String dexProtocolVersion; public String getSymbol() { if(Strings.isNullOrEmpty(middleCoinContractAddress)) { return baseCurrency + &quot;/&quot; + quoteCurrency; }else{ return baseCurrency + &quot;/&quot; + middleCurrency + &quot;/&quot; + quoteCurrency; } } /** * 注意这里是[链上]对应的基础货币 BTC */ private String baseCurrency; /** * 注意这里是[链上]对应的交易对报价货币 USDT */ private String quoteCurrency; /** * 注意这里是[链上]对应的交易对中间报价货币 */ private String middleCurrency; private Set&lt;Integer&gt; chainIds; /** * TODO 未来需要支持一个币种在多个链上的支持, 目前只考虑币种只在一个链上活跃 * @return */ public Integer getFirstChainId(){ return chainIds.iterator().next(); } /**************************************************************************************************/ /************************************** 链上的地址配置信息 *******************************************/ /**************************************************************************************************/ /** * 为了方便存取,围绕token,将常用的信息包装起来 */ private CurrencyBag stable; private CurrencyBag trade; private CurrencyBag middle; public void init() { if (stable == null) { stable = CurrencyBag.of(stableCoinContractAddress, quoteCurrency, getStableCoinDecimals()); } if (trade == null) { trade = CurrencyBag.of(tradeCoinContractAddress, baseCurrency, getTradeCoinDecimals()); } if (middle == null) { middle = CurrencyBag.of(middleCoinContractAddress, middleCurrency, getMiddleCoinDecimals()); } } /** * 稳定币的合约地址 * USTD,ETH,BTC 等 */ private String stableCoinContractAddress; /** * 中间币的合约地址 * BNB 有自己独立的链的等 */ private String middleCoinContractAddress; /** * 交易币的合约地址 * 即最终操作的目标币地址 * 原代码中的:swapCoinContractAdd */ private String tradeCoinContractAddress; /** * v3流通性的合约地址 */ private String v3LoopContractAddress; /** * v3手续费的 */ private String v3Fee; /** * 去中心化交易所的合约地址 */ private String swapContractAddress; /** * 反向套利，从蛋糕到交易所，稳定币额度 * bnb对就进行交易所价格查询，转换成对应的bnb * &lt;pre&gt; * 声明 BidDepths,bidOnePrice,BidDepthsAllAmount; * swapStableCoinNumOut = bidOnePrice * BidDepthsAllAmount; * &lt;/pre&gt; */ private AtomicDouble swapStableCoinNumOut; /** * 非稳定币的兑换数量,个数 */ private AtomicDouble swapFStableCoinNum; /** * 稳定币的兑换数量,个数 */ private AtomicDouble swapStableCoinNum; /** * 价格精度 最小就是0.0001 */ private String priceDecimals; /** * 数量精度 最小就是0.01 */ private String numDecimals; /** * 卖时燃烧的手续费 */ private BigDecimal burnFee; /** * 其他费用，初步用来保存转移费用，有些币种的转移费用 */ private BigDecimal otherFee = BigDecimal.ZERO; /** * 链上买币滑点 */ private BigDecimal dexBuySlipPoint; private BigDecimal _origin_dexBuySlipPoint; /** * 买时 税率 */ private BigDecimal buyTax = BigDecimal.ZERO; /** * 卖时 税率 */ private BigDecimal sellTax = BigDecimal.ZERO; /** * 交易币的精度,在程序启动时通过TokenClient从链上合约中查询 */ private int tradeCoinDecimals = 0; /** * 稳定币的精度,在程序启动时通过TokenClient从链上合约中查询 */ private int stableCoinDecimals = 0; /** * 中间币的精度,在程序启动时通过TokenClient从链上合约中查询 */ private int middleCoinDecimals = 0; /** * 链上固定最大下单金额(usdt为单位) */ private BigDecimal dexMaxOrderForUSDT; /** * 链上固定最小下单金额(usdt为单位) */ private BigDecimal dexMinOrderForUSDT; /** * dex购买状态，用于判断是否蛋糕买了，然后回交易所 * 对于这种情况，要进行停止蛋糕购买及交易所到蛋糕的业务 * 根据交易所充值到账时间 一般需要2分钟，即120秒，那130秒内都必须把价格降 */ private AtomicLong dexBuyTimestamp = new AtomicLong(0); private String method; /** * 反向套利时，需要监控买盘的数据， 这是买盘的位置 * 对应的是centerSymbolInfo的askPosition */ private int buyPosition; /** * 反向套利时，深度需要*depthPro ，进行打折 */ private BigDecimal depthPro; public DecenterSymbolInfo setDexBuySlipPoint(BigDecimal dexBuySlipPoint) { this.dexBuySlipPoint = dexBuySlipPoint; // 保留原始值用于恢复 this._origin_dexBuySlipPoint = dexBuySlipPoint; return this; } private ExtensionDexHandlerConfig extensionDexHandlerConfig; /** * 反向套利时的放大比例 */ private BigDecimal replyPro; public boolean isV3(){ return getDexProtocolVersion().toLowerCase().contains(&quot;v3&quot;.toLowerCase()); } public boolean isV2(){ return getDexProtocolVersion().toLowerCase().contains(&quot;v2&quot;.toLowerCase()); } /** * 对dexBuySlipPoint滑点1.5倍； */ public void setDexBuySlipPointDouble() { dexBuySlipPoint = dexBuySlipPoint.multiply(replyPro); } public void resetDexBuySlipPoint() { dexBuySlipPoint = _origin_dexBuySlipPoint; }}","link":"/2024/11/05/carry_coin_architecture_4/"},{"title":"Carry-Coin 架构设计 Core模块(2)","text":"Carry-Coin Core的PipelineAction，Job的设计 Action 组成部分 AbstractForwardPipeline 正向套利(cex-&gt;dex)流水线抽象类 AbstractReversePipeline 逆向套利(dex-&gt;cex)流水线抽象类 CommonCutOffForwardPipeline CommonLimitWaitForwardPipeline CommonReversePipeline DebugReversePipeline WithdrawAndSellPipeline Cex账户留币策略时触发：当账户留币且链上价格比交易所高时，提现-&gt;dex-&gt;卖出 DepositAndSellPipeline Dex留币策略触发：钱包中留币且交易所价格大于链上：充币-&gt;cex-&gt;卖出 OnlySwapInChainPipeline Dex留币策略触发：钱包中留币且链上价格高于Cex：卖出 SolanaReversePipeline Solana逆向套利流水线 TransactionRecordFactory Job 组成部分 异步任务，优先使用websocket取数，如cex不支持则使用rest方式，rest调用一定要实现限频策略，具体见Xchange BalanceRest200msJob 每200ms 调rest接口取余额； ChainAccountMonitor10mJob 每10分钟 监控链上账户余额； CleanBalance1mJob 每1分钟 扫描账户符合条件触发留币策略 ConsumerMiddleCoinBuyAndSellJob 三角套利时，中间币消耗情况入库，订阅的交易所购买中间币（目前BNB,SOL） FundingRecordRest200msJob 每200ms 调rest接口取充提记录监控充提状态； LoaderDataContextMonitor1sJob 最初构想用来存储下单时，当前depth,ticker,orderbook等数据，数据量太大，有条件的情况下上nosql, 就不入db了； PendingPlaceOrderJob 定时扫描未完成订单，并尝试重试 ResetSymbolConfigJob 重置套利币本配置 RiseMonitorRest10sJob SelfOrderRest100msJob","link":"/2024/10/15/carry_coin_architecture_3/"},{"title":"Carry-Coin 中 Jasypt 的应用","text":"自从最近L君小弟电脑中毒，疑似私钥泄漏，导致3W u被盗，反观我的程序一直以来裸奔的状态下，再次菊花一紧。于是，我开始了对Spring Boot的jasypt加密配置的研究。 最坏情况服务器即使被黑，也要尽可能保证程序的安全。 配置文件中关键信息： 交易所token，钱包私钥加密； jar中yml打包时排除，服务器上用密文配置执行； 解密密码动态设置； jasypt 集成程序引入pom.xml 12345 &lt;dependency&gt; &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt; &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt;&lt;/dependency&gt; application.yml 123jasypt: encryptor: password: ${JASYPT_ENCRYPTOR_PASSWORD} Application.java 12345678910111213141516171819202122/** * &lt;p&gt; @Date : 2023/3/19 &lt;/p&gt; * &lt;p&gt; @author konbluesky &lt;/p&gt; */@SpringBootApplication(scanBasePackages = &quot;com.block&quot;)@EnableScheduling@EnableAsync@EnableJpaAuditing// WARN bad smell@EncryptablePropertySources({ @EncryptablePropertySource(value = &quot;file:./config/application.yml&quot;,ignoreResourceNotFound = true), @EncryptablePropertySource(value = &quot;classpath:application.yml&quot;,ignoreResourceNotFound = true)})@EnableEncryptablePropertiespublic class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); }} 打包排除pom.xml,设置打包时排除yml文件，避免铭文yml误打包到jar中 123456789101112 &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;!-- 用springboot 打包时 排除yml--&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.yml&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt;&lt;/resources&gt; 启动脚本原启动方式需要通过-Djasypt.encryptor.password=”the password”,来设置加密密码。这种方式用jps -mlv可以看到启动命令，但是这种方式不安全，依然容易泄露密码。为了安全起见，我们需要在启动脚本中设置环境变量 JASYPT_ENCRYPTOR_PASSWORD 来加密配置文件中的敏感信息。设置后又担心环境变量被echo出来，所以需要设置环境变量时，需要隐藏输入内容同时控制变量作用域在shell内部； 最终脚本如下，关键语句是export和unset； 12345678910111213141516171819202122232425262728293031323334353637383940#!/bin/bash# 获取当前脚本所在目录的绝对路径SCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;$0&quot;)&quot; &amp;&amp; pwd)&quot;# 进入脚本所在目录cd &quot;$SCRIPT_DIR&quot;# 提示用户输入 JASYPT_ENCRYPTOR_PASSWORD，并隐藏输入内容read -sp &quot;Enter App password: &quot; JASYPT_PASSWORDechoexport JASYPT_ENCRYPTOR_PASSWORD=$JASYPT_PASSWORD# 检查是否输入了 JASYPT_ENCRYPTOR_PASSWORDif [ -z &quot;$JASYPT_PASSWORD&quot; ]; then echo &quot;jasypt.encryptor.password is required.&quot; exit 1fi# 启动Java程序并使用nohup确保它在后台运行nohup java -jar $(ls -t trade-monitor-*.jar | head -1) \\ --spring.config.location=file:./config/ \\ --spring.application.name=gateio\\ -XX:+PrintGCDetails \\ -XX:+PrintGCDateStamps \\ -Xloggc:$SCRIPT_DIR/gc.log \\ -Xmx16G \\ -Xms8G \\ -XX:+UseG1GC \\ -XX:NewRatio=3 \\ -XX:SurvivorRatio=8 \\ -XX:MaxMetaspaceSize=1024M \\ -XX:MaxGCPauseMillis=200 \\ -Xss1M &gt;/dev/null 2&gt;&amp;1 &amp;# 清除环境变量unset JASYPT_ENCRYPTOR_PASSWORD","link":"/2024/07/13/carry_coin_jasypt/"},{"title":"Google 2FA 脚本","text":"批量显示Google 2FA 工具，5秒刷新一次 secrets.csv 123456789101112131415username,secretiAvloyola,ENOG7VLRJJ7GDNZJLilBlue561,IWPTHMCHSR74EOSHKwaciWorsnop,TUXN5TNLTKOPTJEYvikeshchotai,L333DPD5JHXF3O2Kperaltasocimo,UH4EDK7425BFCXSHmakzuzu,OUIG375O7OARDXLJJsaFikitha,AIWBIBQGXZK3ZDE3limliangtung,HHD2VM5LHCV6TDOVsinhde18,L6LYS4ECQL5KKPFFActionDT,O64IEGT5NPCOHCQtimansur,3ASN5ZIGJH4ICYUXDarmyrez,BTKNH5OMOMPZ7CFYaninditamario,G2VHH4IHFE367PNWizzanfurkan,EYP7VV6AK6EIDIJB 批量显示验证码脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import csvimport datetimeimport pyotpimport timeimport osimport base64# 定义读取CSV文件的函数def read_secrets_from_csv(csv_file_path): secrets = [] with open(csv_file_path, mode='r') as file: reader = csv.DictReader(file) for row in reader: secrets.append(row) return secrets# 定义验证Base32密钥的函数def is_valid_base32(secret): try: # 尝试解码，如果失败则说明不是有效的Base32 base64.b32decode(secret, casefold=True) return True except (base64.binascii.Error, ValueError): return False# 定义生成2FA验证码的函数def generate_2fa_codes(secrets): codes = [] for secret in secrets: if is_valid_base32(secret['secret']): totp = pyotp.TOTP(secret['secret']) code = totp.now() codes.append({'username': secret['username'], 'code': code}) else: codes.append({'username': secret['username'], 'code': '无效的Base32密钥'}) return codes# 主函数def main(): csv_file_path = '2fa/secrets.csv' # 请根据实际情况修改CSV文件路径 secrets = read_secrets_from_csv(csv_file_path) while True: os.system('cls' if os.name == 'nt' else 'clear') # 清屏 codes = generate_2fa_codes(secrets) print(f&quot;时间:{datetime.datetime.now()}&quot;) for entry in codes: print(f&quot;用户 {entry['username']} 的当前2FA验证码是: {entry['code']}&quot;) time.sleep(5) # 每30秒刷新一次if __name__ == &quot;__main__&quot;: main()","link":"/2024/11/03/google-2fa/"},{"title":"使用 Python 脚本清理 Carry-Coin 程序中的 Logback 日志","text":"随着监控的币种越来越多，我的 Carry-Coin 程序中日志数据的日质量也不断增加，每天的日志文件大小达到约 40G。这不仅占用了大量的存储空间，还给日志分析带来了挑战。为了更有效地管理这些日志，我已经编写了一个程序来提取日志中与交易相关的信息，供后续分析使用。 然而，在配置 Logback 的 logback-spring.xml 文件时，我设置了 appender.rollingPolicy.maxHistory 字段，旨在只保留最近 2 天的日志。然而，这一配置并未如预期生效。因此，我决定暂时使用 Python 脚本来手动清理旧的日志文件。 问题背景在 Carry-Coin 程序中，随着对越来越多币种的监控，日志文件的大小急剧增加，导致每天产生的日志文件约为 40G。虽然我已编写程序提取交易信息，但大量的日志数据依然占用了过多的磁盘空间。为此，我尝试通过调整 Logback 的配置来限制保留的日志数量。 Logback 日志管理为了管理日志，我在 logback-spring.xml 文件中配置了以下内容： 12345678910&lt;appender name=&quot;ROLLING&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;file&gt;logs/carry-coin.log&lt;/file&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;logs/carry-coin.%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;2&lt;/maxHistory&gt; &lt;!-- 只保留最近2天的日志 --&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss} %-5level %logger{36} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt;&lt;/appender&gt; 尽管如此，maxHistory 的配置并未生效，因此需要寻找替代解决方案。 Python 脚本实现我编写了一个 Python 脚本来自动清理日志文件，保留最近 2 天的日志。以下是脚本的实现： 12345678910111213141516171819202122import osimport timefrom datetime import datetime, timedelta# 获取两天前的时间days_to_keep = 2cutoff_time = datetime.now() - timedelta(days=days_to_keep)# 定义日志目录log_directory = &quot;/path/to/logs&quot;# 遍历日志目录，删除修改时间在 cutoff_time 之前的 .log 文件for filename in os.listdir(log_directory): file_path = os.path.join(log_directory, filename) if os.path.isfile(file_path) and filename.endswith(&quot;.log&quot;): file_mtime = os.path.getmtime(file_path) file_mtime_dt = datetime.fromtimestamp(file_mtime) if file_mtime_dt &lt; cutoff_time: os.remove(file_path) print(f&quot;Deleted: {file_path}&quot;) 说明 脚本获取当前时间的两天前，遍历指定日志目录，删除修改时间在该时间之前的 .log 文件。 仅处理以 .log 结尾的文件，确保只删除日志文件。 设置 Cron 定时任务为了定期执行这个清理脚本，我使用 cron 设置了一个定时任务，以下是设置步骤： 打开 crontab 编辑器： 1crontab -e 添加如下定时任务，每天凌晨 1 点执行： 10 1 * * * /usr/bin/python3 /path/to/your_script.py &gt;&gt; /path/to/cron_log.log 2&gt;&amp;1 保存并退出 crontab。 总结通过使用 Python 脚本，我能够有效地管理 Carry-Coin 程序中生成的日志文件，避免了因日志文件过大导致的磁盘空间不足的问题。虽然 Logback 的配置未能如预期生效，但临时解决方案为我带来了便利。在未来的项目中，我将继续探索更好的日志管理策略，以确保程序高效运行。 参考文档 Logback 文档","link":"/2024/02/13/carry_coin_log_cleanup/"},{"title":"BSC节点区块监控脚本","text":"脚本主要监听私有BSC节点区块状态，如发生区块漏块过多，发送告警消息到DD群中，carry-coin调整rpc访问策略； 监控脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123from web3 import Web3import timeimport threadingimport sysimport loggingfrom logging.handlers import TimedRotatingFileHandlerimport osfrom stop_event_trigger import StopEventTrigger# 日志配置log_dir = &quot;logs&quot;if not os.path.exists(log_dir): os.makedirs(log_dir)app_name=&quot;block_monitor-7.143&quot;can_call=Falsestop_event_trigger = StopEventTrigger()log_file = os.path.join(log_dir, &quot;block_monitor.log&quot;)# 创建一个TimedRotatingFileHandler，用于按照日期切割日志文件file_handler = TimedRotatingFileHandler(log_file, when=&quot;midnight&quot;, interval=1, backupCount=7, encoding='utf-8')file_handler.setFormatter(logging.Formatter(app_name+' %(asctime)s - %(levelname)s - %(message)s'))# 创建一个StreamHandler，用于将日志输出到控制台console_handler = logging.StreamHandler()console_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))# 配置root loggerlogging.basicConfig(level=logging.INFO, handlers=[file_handler, console_handler])from chatbot import DingtalkChatbot# 配置 DingTalk 消息通知webhook = &quot;https://oapi.dingtalk.com/robot/send?access_token={机器人TOKEN}&quot;secret = &quot;SEC开头密钥&quot;dd = DingtalkChatbot(webhook, secret=secret, fail_notice=True)private_rpc_url = &quot;http://私有节点ip:8545/&quot;# 公共节点public_rpc_urls = [ &quot;https://bsc-dataseed.binance.org&quot;, &quot;https://bsc-dataseed1.defibit.io&quot;, &quot;https://bsc-dataseed1.binance.org&quot;, &quot;https://bsc-dataseed2.defibit.io&quot;, &quot;https://bsc-dataseed3.ninicoin.io&quot;]def get_ethereum_block_height(rpc_url): start_time = time.time() # 记录开始时间 web3 = Web3(Web3.HTTPProvider(rpc_url)) block_height = web3.eth.block_number end_time = time.time() # 记录结束时间 elapsed_time = end_time - start_time logging.info(f&quot;节点 {rpc_url} 当前区块高度: {block_height}，查询耗时: {elapsed_time:.3f}秒&quot;) return block_heightdef send_dingtalk_message(message): dd.send_text(msg=message)def monitor_block_height(private_rpc_url, public_rpc_urls): inspection_timer = 0 # 初始化巡检计时器，单位为秒 while True: try: my_block_height = get_ethereum_block_height(private_rpc_url) # 获取所有节点的区块高度 public_block_heights = [get_ethereum_block_height(url) for url in public_rpc_urls] logging.info(f&quot;私有节点高度:{my_block_height} 所有节点的区块高度: {public_block_heights}&quot;) # 找到最大的区块高度 max_block_height = max(public_block_heights) logging.info(f&quot;最大区块高度: {max_block_height}&quot;) # 比对节点是否领先 # 如果私有节点的区块高度小于最大区块高度，并且区块差异大于3 则发送警告 diff_height = max_block_height - my_block_height if my_block_height &lt; max_block_height and diff_height &gt; 3: # if my_block_height &lt; max_block_height: currentTime = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime()) message = f&quot;{app_name}私有节点 {my_block_height} 低于于其他节点，最大区块高度为 {max_block_height}，差异:{diff_height} 时间 {currentTime}&quot; logging.warning(message) # 使用警告级别的日志 send_dingtalk_message(message) if can_call: stop_event_trigger.pin_point_and_stop_engine_event() # 每隔10分钟发送一次巡检记录 if inspection_timer &gt;= 1800: currentTime = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime()) inspection_message = f&quot;{app_name} 巡检记录：私有节点 {my_block_height}，&quot; inspection_message += f&quot;公共节点最大区块高度: {max_block_height}，&quot; inspection_message += f&quot;时间 {currentTime}&quot; logging.info(inspection_message) send_dingtalk_message(inspection_message) inspection_timer = 0 # 重置计时器 except Exception as e: logging.error(f&quot;发生错误：{e}&quot;) time.sleep(5) inspection_timer += 5 # 每次循环增加计时器的时间，单位为秒if __name__ == &quot;__main__&quot;: # 读取命令行传入参数 if len(sys.argv) &gt; 1: app_name = sys.argv[1] if app_name is None: app_name = &quot;block_monitor&quot; if len(sys.argv) &gt; 2: canCall = sys.argv[2] if canCall is None: canCall = False if can_call: stop_event_trigger.pin_point_and_stop_engine_event(app_name) logging.info(f&quot;app_name: {app_name}&quot;) t = threading.Thread(target=monitor_block_height, args=(private_rpc_url, public_rpc_urls)) t.start() t.join() 启动脚本 1234567891011121314#!/bin/bash# 增加一个启动参数，app_name,如传入则使用传入的app_name，并加入到启动命令中app_name=$1# 设置启动日志文件路径start_log_file=&quot;logs/start_script.log&quot;# 启动 Python 脚本，并将输出保存到启动日志文件nohup python3.10 monitor.py $app_name &gt; $start_log_file 2&gt;&amp;1 &amp;# 获取启动的 Python 进程的PID并保存到文件中echo $! &gt; pid_file.txtecho &quot;脚本已在后台运行。PID为：$(cat pid_file.txt)&quot; 停止脚本 12345678910111213141516#!/bin/bash# 获取之前保存的PID文件pid_file=&quot;pid_file.txt&quot;pid=$(cat $pid_file 2&gt;/dev/null)if [ -z &quot;$pid&quot; ]; then echo &quot;未找到PID。脚本可能未在运行。&quot;else # 终止Python进程 kill -TERM $pid echo &quot;PID为 $pid 的脚本已停止。&quot; # 删除PID文件 rm $pid_filefi","link":"/2024/11/02/node-monitor/"},{"title":"Carry-Coin 记服务迁移和流量优化","text":"最近Contabo服务器频繁死机，发邮件给官方反应问题，一开始嘴硬说没问题让自查，沟通2天又是截图又是各种开票，最后承认问题说技术团队排查但是不给解决时间 邮件回复 VNC过去看到 sda3硬盘一直挂不上/dev/sda3: recovering journal，猜测不是硬件存储坏了就是虚拟化平台抽风；好在重启5-8次大概能进系统一次，赶紧拷数据闪人； 目前部署架构 原来contabo的机器8u24g,32TTraffic一个月$26, 相同配置国内厂商看了一圈没有羊毛，最后选择tx，但是相同配置明显贵上天，只能调整架构先开台低配2u4g/90ssd轻量服务器,把front、server、db弄回来，worker后面再说； 程序迁移后大问题没有，每种不足就是出口流量太吃紧了，轻量应用流量包只有2T,跑了10个小时流量80多G，一天毛估估200G； 优化过程iftop大概观察下流量去向，其实心里也有数，整机对外一个是通过nginx访问的front 这是给自己看的前端,还有一个就是mysql,几个worker每秒多线程读写，这部分传输过程中流量花费巨大；资源的话cpu的使用率基本维持在50左右，内存40%左右，优化空间还是有的 jeecgboot 前端肿的不行，所以nginx gzip该压的压起来,改了后观察监控发现提升可以忽略不计。 mysql是大头，这块翻了一些优化料大部分都是持久化侧的，表压缩之类的；所以换了个思路，既然是传输过程中的损耗那么大概率是jdbc驱动的事情，这么常规的场景应该有支持； 翻了mysql-connector-j-8.0.33.jar代码发现果然有戏com.mysql.cj.protocol.a.NativeProtocol中有个字段useCompression开启后mysql的传输过程会压缩，但是默认是关闭的，可以在jdbc连接字符串后面加上useCompression=true来开启压缩； CompressedPacketSender开关打开后会使用com.mysql.cj.protocol.a.CompressedPacketSender来发送数据； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * Packet sender implementation for the compressed MySQL protocol. For compressed transmission of multi-packets, split the packets up in the same way as the * uncompressed protocol. We fit up to MAX_PACKET_SIZE bytes of split uncompressed packet, including the header, into an compressed packet. The first packet * of the multi-packet is 4 bytes of header and MAX_PACKET_SIZE - 4 bytes of the payload. The next packet must send the remaining four bytes of the payload * followed by a new header and payload. If the second split packet is also around MAX_PACKET_SIZE in length, then only MAX_PACKET_SIZE - 4 (from the * previous packet) - 4 (for the new header) can be sent. This means the payload will be limited by 8 bytes and this will continue to increase by 4 at every * iteration. * * @param packet * data bytes * @param packetLen * packet length * @param packetSequence * sequence id * @throws IOException * if i/o exception occurs */ public void send(byte[] packet, int packetLen, byte packetSequence) throws IOException { this.compressedSequenceId = packetSequence; // short-circuit send small packets without compression and return if (packetLen &lt; MIN_COMPRESS_LEN) { writeCompressedHeader(packetLen + NativeConstants.HEADER_LENGTH, this.compressedSequenceId, 0); writeUncompressedHeader(packetLen, packetSequence); this.outputStream.write(packet, 0, packetLen); this.outputStream.flush(); return; } if (packetLen + NativeConstants.HEADER_LENGTH &gt; NativeConstants.MAX_PACKET_SIZE) { this.compressedPacket = new byte[NativeConstants.MAX_PACKET_SIZE]; } else { this.compressedPacket = new byte[NativeConstants.HEADER_LENGTH + packetLen]; } PacketSplitter packetSplitter = new PacketSplitter(packetLen); int unsentPayloadLen = 0; int unsentOffset = 0; // loop over constructing and sending compressed packets while (true) { this.compressedPayloadLen = 0; if (packetSplitter.nextPacket()) { // rest of previous packet if (unsentPayloadLen &gt; 0) { addPayload(packet, unsentOffset, unsentPayloadLen); } // current packet int remaining = NativeConstants.MAX_PACKET_SIZE - unsentPayloadLen; // if remaining is 0 then we are sending a very huge packet such that are 4-byte header-size carryover from last packet accumulated to the size // of a whole packet itself. We don't handle this. Would require 4 million packet segments (64 gigs in one logical packet) int len = Math.min(remaining, NativeConstants.HEADER_LENGTH + packetSplitter.getPacketLen()); int lenNoHdr = len - NativeConstants.HEADER_LENGTH; addUncompressedHeader(packetSequence, packetSplitter.getPacketLen()); addPayload(packet, packetSplitter.getOffset(), lenNoHdr); completeCompression(); // don't send payloads with incompressible data if (this.compressedPayloadLen &gt;= len) { // combine the unsent and current packet in an uncompressed packet writeCompressedHeader(unsentPayloadLen + len, this.compressedSequenceId++, 0); this.outputStream.write(packet, unsentOffset, unsentPayloadLen); writeUncompressedHeader(lenNoHdr, packetSequence); this.outputStream.write(packet, packetSplitter.getOffset(), lenNoHdr); } else { sendCompressedPacket(len + unsentPayloadLen); } packetSequence++; unsentPayloadLen = packetSplitter.getPacketLen() - lenNoHdr; unsentOffset = packetSplitter.getOffset() + lenNoHdr; resetPacket(); } else if (unsentPayloadLen &gt; 0) { // no more packets, send remaining unsent data addPayload(packet, unsentOffset, unsentPayloadLen); completeCompression(); if (this.compressedPayloadLen &gt;= unsentPayloadLen) { writeCompressedHeader(unsentPayloadLen, this.compressedSequenceId, 0); this.outputStream.write(packet, unsentOffset, unsentPayloadLen); } else { sendCompressedPacket(unsentPayloadLen); } resetPacket(); break; } else { // nothing left to send (only happens on boundaries) break; } } this.outputStream.flush(); // release reference to (possibly large) compressed packet buffer this.compressedPacket = null; } 整体思路高效地发送数据包，无论是小包还是大包，同时通过压缩减少传输数据的大小。它通过拆分、压缩和适当的序列管理确保数据完整和顺序发送. 改了以后程序跑起来，超出预期,流量消耗少了近50%，代价是cpu提了10%左右，划算。 先跑着一个月后再看。","link":"/2024/09/02/traffic_optimization_idea/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Architecture","slug":"Architecture","link":"/tags/Architecture/"},{"name":"jasypt","slug":"jasypt","link":"/tags/jasypt/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"日志清理","slug":"日志清理","link":"/tags/%E6%97%A5%E5%BF%97%E6%B8%85%E7%90%86/"},{"name":"bsc","slug":"bsc","link":"/tags/bsc/"},{"name":"optimization","slug":"optimization","link":"/tags/optimization/"}],"categories":[{"name":"Carry Coin","slug":"Carry-Coin","link":"/categories/Carry-Coin/"}],"pages":[{"title":"about me","text":"姓名 Gong Wei性别 男工作经验 10years+学历 本科学校 北京航空航天大学 - 计算机科学与技术邮箱 blackjackhoho@gmail.comTelegram @blackjackhohoGithub https://github.com/konbluesky 14年的老开发,在寻找一个激情、开放、和谐的团队，与志同道合的伙伴共同创造卓越的项目。 基础技能 精通Java,超过10年的企业级Java程序开发经验,对项目中用到的框架包括但不限于（Spring Full Stack,Mybatis，Netty等）有Cover和Hack能力; 熟悉Nodejs、Python、Shell等动态语言,能够灵活运用这些脚本语言解决项目中的碎片化问题,如原型验证、数据处理、自动化脚本等； 擅长OOP&amp;OOD,有复杂系统0-1设计和1-N的重构经验； 擅长Linux下工作和DevOps实践；","link":"/about/index.html"}]}